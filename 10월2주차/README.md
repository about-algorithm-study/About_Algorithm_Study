# 10ì›” 2ì£¼ì°¨

## ğŸ“… ê¸°ê°„: 2025.10.08 ~ 2025.10.12

## ğŸ¯ ì£¼ì œ: ì‚¼ì„± SW ì—­ëŸ‰ í…ŒìŠ¤íŠ¸ ì‹¬í™” (IM + Aí˜• ê³ ê¸‰)

---

## ğŸ“ ë¬¸ì œ ëª©ë¡

### ğŸ”° IM ìˆ˜ì¤€ ë¬¸ì œ (6ê°œ)

| ë²ˆí˜¸ | ë¬¸ì œëª… | ë‚œì´ë„ | ë¶„ë¥˜ | ì¶”ì²œ ì´ìœ  | ë§í¬ |
|------|---------|--------|------|-----------|------|
| SWEA_1928 | Base64 Decoder | D2 | ë¬¸ìì—´/ì¸ì½”ë”© | ë¬¸ìì—´ ë³€í™˜ ë° ë¹„íŠ¸ ì—°ì‚° | [ë§í¬](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PR4DKAG0DFAUq) |
| SWEA_1859 | ë°±ë§Œ ì¥ì í”„ë¡œì íŠ¸ | D2 | Greedy | ì—­ë°©í–¥ íƒìƒ‰ ì „ëµ | [ë§í¬](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5LrsUaDxcDFAXc) |
| SWEA_1940 | ê°€ë! RCì¹´! | D2 | ì‹œë®¬ë ˆì´ì…˜ | ê°€ì†ë„ ì‹œë®¬ë ˆì´ì…˜ êµ¬í˜„ | [ë§í¬](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PjMgaALgDFAUq) |
| SWEA_1948 | ë‚ ì§œ ê³„ì‚°ê¸° | D2 | êµ¬í˜„/ë‚ ì§œ | ë‚ ì§œ ê°„ê²© ê³„ì‚° ë¡œì§ | [ë§í¬](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PnnU6AOsDFAUq) |
| SWEA_2805 | ë†ì‘ë¬¼ ìˆ˜í™•í•˜ê¸° | D3 | êµ¬í˜„/2ì°¨ì›ë°°ì—´ | ë‹¤ì´ì•„ëª¬ë“œ ëª¨ì–‘ ì˜ì—­ íƒìƒ‰ | [ë§í¬](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV7GLXqKAWYDFAXB) |
| SWEA_1215 | íšŒë¬¸1 | D3 | ë¬¸ìì—´/ì™„ì „íƒìƒ‰ | íšŒë¬¸ íŒë³„ ì•Œê³ ë¦¬ì¦˜ | [ë§í¬](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV14QpAaAAwCFAYi) |

### ğŸ† Aí˜• ìˆ˜ì¤€ ë¬¸ì œ (3ê°œ)

| ë²ˆí˜¸ | ë¬¸ì œëª… | ë‚œì´ë„ | ë¶„ë¥˜ | ì¶”ì²œ ì´ìœ  | ë§í¬ |
|------|---------|--------|------|-----------|------|
| SWEA_1767 | í”„ë¡œì„¸ì„œ ì—°ê²°í•˜ê¸° | D4 | ë°±íŠ¸ë˜í‚¹/DFS | ìµœì í™” ë°±íŠ¸ë˜í‚¹ ì‹¬í™” | [ë§í¬](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV4suNtaXFEDFAUf) |
| SWEA_2117 | í™ˆ ë°©ë²” ì„œë¹„ìŠ¤ | D4 | BFS/ì‹œë®¬ë ˆì´ì…˜ | ë‹¤ì´ì•„ëª¬ë“œ ë²”ìœ„ BFS | [ë§í¬](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5V61LqAf8DFAWu) |
| SWEA_2383 | ì ì‹¬ ì‹ì‚¬ì‹œê°„ | D4 | ì‹œë®¬ë ˆì´ì…˜/ì¡°í•© | ë³µì¡í•œ ì‹œë®¬ë ˆì´ì…˜ êµ¬í˜„ | [ë§í¬](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5-BEE6AK0DFAVl) |

---

## ğŸ“Š ì§„í–‰ í˜„í™©

| ë©¤ë²„ | ì§„í–‰ë¥  | í’€ì´ ë¬¸ì œ ìˆ˜ | ë¹„ê³  |
|------|--------|-------------|------|
| ê¹€ê°•ì—° | 0.0% â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ | 0/9 | â³ |
| ì‹ ì¬í˜ | 44.4% ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©â¬œâ¬œâ¬œâ¬œâ¬œ | 4/9 | â³ |
| ì˜¤ì°½ë¯¼ | 44.4% ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©â¬œâ¬œâ¬œâ¬œâ¬œ | 4/9 | â³ |
| ì†¡ë¯¼ê²½ | 0.0% â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ | 0/9 | â³ |
| ìµœì¬ê° | 0.0% â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ | 0/9 | â³ |

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2025-10-21 08:52

---

## ğŸ’¡ í•™ìŠµ í¬ì¸íŠ¸

### ğŸ“š IM ìˆ˜ì¤€ ë¬¸ì œ ê³µëµë²•

#### 1. SWEA_1928 - Base64 Decoder (D2)
- **í•µì‹¬**: Base64 ë””ì½”ë”© ì›ë¦¬ ì´í•´
- **Python í™œìš©**: `base64` ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
- **ì‹œê°„ ë³µì¡ë„**: O(N)

**ì ‘ê·¼ë²•**:
```python
import base64

encoded = input().strip()
decoded = base64.b64decode(encoded).decode('utf-8')
print(decoded)
```

**ìˆ˜ë™ êµ¬í˜„ (ì‹¬í™”)**:
```python
# Base64 ë¬¸ì í…Œì´ë¸”
table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

def decode_base64(s):
    binary = ""
    # ê° ë¬¸ìë¥¼ 6ë¹„íŠ¸ë¡œ ë³€í™˜
    for c in s:
        if c != '=':
            binary += format(table.index(c), '06b')
    
    # 8ë¹„íŠ¸ì”© ì˜ë¼ì„œ ë¬¸ìë¡œ ë³€í™˜
    result = ""
    for i in range(0, len(binary), 8):
        if i + 8 <= len(binary):
            result += chr(int(binary[i:i+8], 2))
    
    return result
```

#### 2. SWEA_1859 - ë°±ë§Œ ì¥ì í”„ë¡œì íŠ¸ (D2)
- **í•µì‹¬**: ë’¤ì—ì„œë¶€í„° íƒìƒ‰í•˜ë©° ìµœëŒ€ê°’ ê°±ì‹ 
- **ì‹œê°„ ë³µì¡ë„**: O(N)
- **ì£¼ì˜**: ì•ì—ì„œë¶€í„° í’€ë©´ ì‹œê°„ ì´ˆê³¼!

**ì „ëµ**:
```python
# í•µì‹¬ ì•„ì´ë””ì–´: ë’¤ì—ì„œë¶€í„° ìµœëŒ€ê°’ ì¶”ì 
prices = [list of prices]
max_price = 0
profit = 0

for i in range(len(prices) - 1, -1, -1):
    if prices[i] > max_price:
        max_price = prices[i]
    else:
        profit += max_price - prices[i]

print(profit)
```

**ì™œ ì—­ë°©í–¥?**
- ë¯¸ë˜ì˜ ìµœê³ ê°€ë¥¼ ì•Œê³  ìˆìœ¼ë©´ ê·¸ë•Œ íŒ”ë©´ ë¨
- í˜„ì¬ê°€ < ë¯¸ë˜ ìµœê³ ê°€ â†’ ì§€ê¸ˆ ì‚¬ì„œ ë‚˜ì¤‘ì— íŒ”ê¸°
- í˜„ì¬ê°€ >= ë¯¸ë˜ ìµœê³ ê°€ â†’ ìµœê³ ê°€ ê°±ì‹ 

#### 3. SWEA_1940 - ê°€ë! RCì¹´! (D2)
- **í•µì‹¬**: ì†ë„ì™€ ê±°ë¦¬ ì‹œë®¬ë ˆì´ì…˜
- **ì£¼ì˜**: ì†ë„ê°€ 0 ë¯¸ë§Œì´ ë˜ì§€ ì•Šë„ë¡ ì²˜ë¦¬

**ì‹œë®¬ë ˆì´ì…˜ ë¡œì§**:
```python
speed = 0
distance = 0

for command in commands:
    if command == 0:  # ìœ ì§€
        pass
    elif command == 1:  # ê°€ì†
        speed += acceleration
    elif command == 2:  # ê°ì†
        speed = max(0, speed - deceleration)
    
    distance += speed

print(distance)
```

#### 4. SWEA_1948 - ë‚ ì§œ ê³„ì‚°ê¸° (D2)
- **í•µì‹¬**: ì›”ë³„ ì¼ìˆ˜ë¥¼ ê³ ë ¤í•œ ë‚ ì§œ ê³„ì‚°
- **íŒ**: ë¦¬ìŠ¤íŠ¸ë¡œ ê° ì›”ì˜ ì¼ìˆ˜ ì €ì¥

**ì ‘ê·¼ë²•**:
```python
days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

def count_days(m1, d1, m2, d2):
    total = 0
    
    # ê°™ì€ ì›”ì¸ ê²½ìš°
    if m1 == m2:
        return d2 - d1 + 1
    
    # ì²« ë‹¬ì˜ ë‚¨ì€ ë‚ 
    total += days_in_month[m1] - d1 + 1
    
    # ì¤‘ê°„ ë‹¬ë“¤
    for m in range(m1 + 1, m2):
        total += days_in_month[m]
    
    # ë§ˆì§€ë§‰ ë‹¬
    total += d2
    
    return total
```

#### 5. SWEA_2805 - ë†ì‘ë¬¼ ìˆ˜í™•í•˜ê¸° (D3)
- **í•µì‹¬**: ë‹¤ì´ì•„ëª¬ë“œ(ë§ˆë¦„ëª¨) ì˜ì—­ íƒìƒ‰
- **ì „ëµ**: ì¤‘ì•™ì„ ê¸°ì¤€ìœ¼ë¡œ ê±°ë¦¬ ê³„ì‚°

**ë‹¤ì´ì•„ëª¬ë“œ ì˜ì—­ íƒìƒ‰**:
```python
N = int(input())
farm = [list(map(int, input())) for _ in range(N)]

center = N // 2
total = 0

for i in range(N):
    # ì¤‘ì•™ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬
    distance = abs(i - center)
    
    # ê° í–‰ì—ì„œ ìˆ˜í™• ê°€ëŠ¥í•œ ë²”ìœ„
    start = center - (center - distance)
    end = center + (center - distance)
    
    for j in range(start, end + 1):
        total += farm[i][j]

print(total)
```

**íŒ¨í„´ ì´í•´**:
```
N=5, center=2ì¼ ë•Œ:
í–‰0: distance=2, ë²”ìœ„=[2,2] (1ê°œ)
í–‰1: distance=1, ë²”ìœ„=[1,3] (3ê°œ)
í–‰2: distance=0, ë²”ìœ„=[0,4] (5ê°œ)
í–‰3: distance=1, ë²”ìœ„=[1,3] (3ê°œ)
í–‰4: distance=2, ë²”ìœ„=[2,2] (1ê°œ)
```

#### 6. SWEA_1215 - íšŒë¬¸1 (D3)
- **í•µì‹¬**: ê°€ë¡œ/ì„¸ë¡œ ëª¨ë“  ë¶€ë¶„ ë¬¸ìì—´ íšŒë¬¸ ê²€ì‚¬
- **ì‹œê°„ ë³µì¡ë„**: O(NÂ² Ã— M) (N: ë°°ì—´ í¬ê¸°, M: íšŒë¬¸ ê¸¸ì´)

**íšŒë¬¸ ê²€ì‚¬ ìµœì í™”**:
```python
def is_palindrome(s):
    return s == s[::-1]

def count_palindromes(board, length):
    count = 0
    N = len(board)
    
    # ê°€ë¡œ ê²€ì‚¬
    for i in range(N):
        for j in range(N - length + 1):
            word = ''.join(board[i][j:j+length])
            if is_palindrome(word):
                count += 1
    
    # ì„¸ë¡œ ê²€ì‚¬
    for i in range(N - length + 1):
        for j in range(N):
            word = ''.join(board[i+k][j] for k in range(length))
            if is_palindrome(word):
                count += 1
    
    return count
```

---

### ğŸš€ Aí˜• ìˆ˜ì¤€ ë¬¸ì œ ê³µëµë²•

#### 1. SWEA_1767 - í”„ë¡œì„¸ì„œ ì—°ê²°í•˜ê¸° (D4)
- **ë‚œì´ë„**: â˜…â˜…â˜…â˜…â˜…
- **í•µì‹¬ ì•Œê³ ë¦¬ì¦˜**: ë°±íŠ¸ë˜í‚¹ + ìµœì í™”
- **ëª©í‘œ**: ìµœëŒ€í•œ ë§ì€ í”„ë¡œì„¸ì„œë¥¼ ì—°ê²°í•˜ë˜, ì „ì„  ê¸¸ì´ëŠ” ìµœì†Œí™”

**ì „ëµ**:
1. ê°€ì¥ìë¦¬ì— ìˆëŠ” í”„ë¡œì„¸ì„œëŠ” ì´ë¯¸ ì—°ê²°ë¨ (ì œì™¸)
2. ê° í”„ë¡œì„¸ì„œë§ˆë‹¤ 4ë°©í–¥ + ì—°ê²° ì•ˆ í•¨ (5ê°€ì§€ ì„ íƒ)
3. ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ ëª¨ë“  ê²½ìš° íƒìƒ‰
4. ê°€ì§€ì¹˜ê¸°: ì—°ê²°ëœ í”„ë¡œì„¸ì„œ ìˆ˜ê°€ í˜„ì¬ ìµœëŒ€ë³´ë‹¤ ì ìœ¼ë©´ ì¤‘ë‹¨

**í•µì‹¬ ë¡œì§**:
```python
def can_connect(x, y, direction):
    """í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì—°ê²° ê°€ëŠ¥í•œì§€ í™•ì¸"""
    dx, dy = directions[direction]
    nx, ny = x + dx, y + dy
    
    while 0 <= nx < N and 0 <= ny < N:
        if board[nx][ny] != 0:
            return False, []
        nx += dx
        ny += dy
    
    # ì—°ê²° ê°€ëŠ¥í•œ ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
    path = []
    nx, ny = x + dx, y + dy
    while 0 <= nx < N and 0 <= ny < N:
        path.append((nx, ny))
        nx += dx
        ny += dy
    
    return True, path

def dfs(idx, connected, wire_length):
    global max_connected, min_wire
    
    # ëª¨ë“  í”„ë¡œì„¸ì„œ ì²˜ë¦¬ ì™„ë£Œ
    if idx == len(processors):
        if connected > max_connected:
            max_connected = connected
            min_wire = wire_length
        elif connected == max_connected:
            min_wire = min(min_wire, wire_length)
        return
    
    # ê°€ì§€ì¹˜ê¸°: ë‚¨ì€ í”„ë¡œì„¸ì„œ ëª¨ë‘ ì—°ê²°í•´ë„ ìµœëŒ€ê°’ ëª» ë„˜ìœ¼ë©´ ì¤‘ë‹¨
    if connected + (len(processors) - idx) < max_connected:
        return
    
    x, y = processors[idx]
    
    # ê° ë°©í–¥ ì‹œë„
    for direction in range(4):
        possible, path = can_connect(x, y, direction)
        
        if possible:
            # ì „ì„  ì„¤ì¹˜
            for px, py in path:
                board[px][py] = 2
            
            # ì¬ê·€ í˜¸ì¶œ
            dfs(idx + 1, connected + 1, wire_length + len(path))
            
            # ì „ì„  ì œê±° (ë°±íŠ¸ë˜í‚¹)
            for px, py in path:
                board[px][py] = 0
    
    # ì—°ê²° ì•ˆ í•˜ëŠ” ê²½ìš°
    dfs(idx + 1, connected, wire_length)
```

**ìµœì í™” íŒ**:
- ê°€ì¥ìë¦¬ í”„ë¡œì„¸ì„œ ë¨¼ì € ì œì™¸
- ë¶ˆê°€ëŠ¥í•œ í”„ë¡œì„¸ì„œ íŒŒì•… (4ë°©í–¥ ëª¨ë‘ ë§‰íŒ ê²½ìš°)
- ê°€ì§€ì¹˜ê¸° ê°•í™” (ë‚¨ì€ í”„ë¡œì„¸ì„œë¡œ ìµœëŒ€ê°’ ë„ë‹¬ ë¶ˆê°€ëŠ¥í•˜ë©´ ì¤‘ë‹¨)

#### 2. SWEA_2117 - í™ˆ ë°©ë²” ì„œë¹„ìŠ¤ (D4)
- **ë‚œì´ë„**: â˜…â˜…â˜…â˜…â˜†
- **í•µì‹¬ ì•Œê³ ë¦¬ì¦˜**: BFS + ë‹¤ì´ì•„ëª¬ë“œ ë²”ìœ„
- **ëª©í‘œ**: ì†í•´ë¥¼ ë³´ì§€ ì•Šìœ¼ë©´ì„œ ìµœëŒ€ ì„œë¹„ìŠ¤ ì§‘ ìˆ˜

**ì „ëµ**:
1. ëª¨ë“  ìœ„ì¹˜ì—ì„œ ì„œë¹„ìŠ¤ ì˜ì—­ Kë¥¼ 1ë¶€í„° ì¦ê°€ì‹œí‚¤ë©° í™•ì¸
2. ê° Kì— ëŒ€í•´ ë‹¤ì´ì•„ëª¬ë“œ ë²”ìœ„ ë‚´ ì§‘ ê°œìˆ˜ ê³„ì‚°
3. ë¹„ìš© ê³„ì‚°: KÂ² + (K-1)Â²
4. ìˆ˜ìµ >= ë¹„ìš©ì¸ ê²½ìš°ë§Œ ì¹´ìš´íŠ¸

**ë‹¤ì´ì•„ëª¬ë“œ ë²”ìœ„ ê³„ì‚°**:
```python
def get_houses_in_range(cx, cy, k):
    """ì¤‘ì‹¬ (cx, cy)ì—ì„œ ê±°ë¦¬ K ì´ë‚´ ì§‘ ê°œìˆ˜"""
    count = 0
    
    for i in range(N):
        for j in range(N):
            # ë§¨í•´íŠ¼ ê±°ë¦¬ ê³„ì‚°
            distance = abs(i - cx) + abs(j - cy)
            
            if distance < k and city[i][j] == 1:
                count += 1
    
    return count

def solve():
    max_houses = 0
    
    # ëª¨ë“  ìœ„ì¹˜ì—ì„œ ì‹œë„
    for i in range(N):
        for j in range(N):
            # Kë¥¼ 1ë¶€í„° ìµœëŒ€ê¹Œì§€ ì¦ê°€
            for k in range(1, N + 2):
                # ìš´ì˜ ë¹„ìš©
                cost = k * k + (k - 1) * (k - 1)
                
                # ì„œë¹„ìŠ¤ ê°€ëŠ¥í•œ ì§‘ ìˆ˜
                houses = get_houses_in_range(i, j, k)
                
                # ìˆ˜ìµ
                profit = houses * M
                
                # ì†í•´ë¥¼ ë³´ì§€ ì•Šìœ¼ë©´ì„œ ìµœëŒ€ ì§‘ ìˆ˜
                if profit >= cost:
                    max_houses = max(max_houses, houses)
    
    return max_houses
```

**ìµœì í™”**:
- BFSë¡œ ê±°ë¦¬ë³„ ì§‘ ê°œìˆ˜ ëˆ„ì  ê³„ì‚°
- Kì˜ ìµœëŒ“ê°’ ì œí•œ (N+2ë©´ ì¶©ë¶„)
- ì†í•´ ë³´ëŠ” ìˆœê°„ í•´ë‹¹ ìœ„ì¹˜ì˜ K ì¦ê°€ ì¤‘ë‹¨

#### 3. SWEA_2383 - ì ì‹¬ ì‹ì‚¬ì‹œê°„ (D4)
- **ë‚œì´ë„**: â˜…â˜…â˜…â˜…â˜…
- **í•µì‹¬ ì•Œê³ ë¦¬ì¦˜**: ì¡°í•© + ì‹œë®¬ë ˆì´ì…˜
- **ëª©í‘œ**: ëª¨ë“  ì‚¬ëŒì´ ê³„ë‹¨ì„ ë‚´ë ¤ê°€ëŠ” ìµœì†Œ ì‹œê°„

**ì „ëµ**:
1. ì‚¬ëŒë“¤ì„ ë‘ ê³„ë‹¨ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ (2^N)
2. ê° ê²½ìš°ë§ˆë‹¤ ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
3. ê³„ë‹¨ ê·œì¹™:
   - ê³„ë‹¨ ì…êµ¬ê¹Œì§€ ì´ë™ ì‹œê°„ = ë§¨í•´íŠ¼ ê±°ë¦¬
   - ê³„ë‹¨ ì…êµ¬ ë„ì°© í›„ 1ë¶„ ëŒ€ê¸°
   - ê³„ë‹¨ ë‚´ë ¤ê°€ëŠ” ì‹œê°„ = ê³„ë‹¨ ê¸¸ì´
   - ê³„ë‹¨ì—ëŠ” ìµœëŒ€ 3ëª…ê¹Œì§€ë§Œ

**ì‹œë®¬ë ˆì´ì…˜ ë¡œì§**:
```python
def simulate(people, stairs, assignment):
    """
    assignment[i] = 0 or 1 (ì–´ëŠ ê³„ë‹¨ìœ¼ë¡œ ê°ˆì§€)
    """
    stair_info = [
        {'pos': stairs[0], 'length': stairs[0][2], 'using': []},
        {'pos': stairs[1], 'length': stairs[1][2], 'using': []}
    ]
    
    # ê° ì‚¬ëŒì˜ ê³„ë‹¨ ë„ì°© ì‹œê°„ ê³„ì‚°
    arrivals = [[] for _ in range(2)]
    for i, person in enumerate(people):
        stair_idx = assignment[i]
        sx, sy = stair_info[stair_idx]['pos'][:2]
        px, py = person
        
        # ì´ë™ ì‹œê°„ + 1ë¶„ ëŒ€ê¸°
        arrival_time = abs(px - sx) + abs(py - sy) + 1
        arrivals[stair_idx].append(arrival_time)
    
    # ê° ê³„ë‹¨ë³„ë¡œ ì‹œë®¬ë ˆì´ì…˜
    max_time = 0
    for stair_idx in range(2):
        if not arrivals[stair_idx]:
            continue
        
        arrivals[stair_idx].sort()
        length = stair_info[stair_idx]['length']
        
        # ê³„ë‹¨ ì‚¬ìš© ì¤‘ì¸ ì‚¬ëŒë“¤ (ì¢…ë£Œ ì‹œê°„ ì €ì¥)
        using = []
        
        for arrival in arrivals[stair_idx]:
            # ê³„ë‹¨ì´ ë¹„ì–´ìˆìœ¼ë©´ ë°”ë¡œ ì‚¬ìš©
            if len(using) < 3:
                using.append(arrival + length)
            else:
                # ê°€ì¥ ë¹¨ë¦¬ ëë‚˜ëŠ” ì‚¬ëŒ ì°¾ê¸°
                using.sort()
                earliest_finish = using[0]
                
                # ë„ì°© ì‹œê°„ê³¼ ê³„ë‹¨ ë¹„ëŠ” ì‹œê°„ ì¤‘ ëŠ¦ì€ ì‹œê°„ë¶€í„° ì‹œì‘
                start_time = max(arrival, earliest_finish)
                using[0] = start_time + length
            
            max_time = max(max_time, max(using))
    
    return max_time

def solve():
    min_time = float('inf')
    
    # ì‚¬ëŒë“¤ì„ ë‘ ê³„ë‹¨ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ëª¨ë“  ê²½ìš°
    for mask in range(1 << len(people)):
        assignment = []
        for i in range(len(people)):
            assignment.append((mask >> i) & 1)
        
        time = simulate(people, stairs, assignment)
        min_time = min(min_time, time)
    
    return min_time
```

---

## ğŸ¯ ì£¼ì°¨ë³„ ëª©í‘œ

### Day 1-2: IM ê¸°ì´ˆ (ë¬¸ìì—´/êµ¬í˜„)
- SWEA_1928, 1859, 1940 í•´ê²°
- Base64, Greedy, ì‹œë®¬ë ˆì´ì…˜ ì—°ìŠµ
- **ëª©í‘œ ì‹œê°„**: ê° 30ë¶„

### Day 3-4: IM ì‹¬í™” (ë°°ì—´/íƒìƒ‰)
- SWEA_1948, 2805, 1215 í•´ê²°
- 2ì°¨ì› ë°°ì—´ íƒìƒ‰ ë§ˆìŠ¤í„°
- **ëª©í‘œ ì‹œê°„**: ê° 40-50ë¶„

### Day 5-7: Aí˜• ê³ ê¸‰ (ë°±íŠ¸ë˜í‚¹/ì‹œë®¬ë ˆì´ì…˜)
- SWEA_1767, 2117, 2383 í•´ê²°
- ë³µì¡í•œ ìµœì í™” ë¬¸ì œ í•´ê²°
- **ëª©í‘œ ì‹œê°„**: ê° 2-3ì‹œê°„

---

## ğŸ“Š ì˜ˆìƒ ì†Œìš” ì‹œê°„

| ë‚œì´ë„ | ë¬¸ì œ ìˆ˜ | ì˜ˆìƒ ì‹œê°„/ë¬¸ì œ | ì´ ì†Œìš” ì‹œê°„ |
|--------|---------|---------------|-------------|
| D2 (IM) | 4ê°œ | 30-40ë¶„ | 2-2.5ì‹œê°„ |
| D3 (IM) | 2ê°œ | 50-60ë¶„ | 2ì‹œê°„ |
| D4 (Aí˜•) | 3ê°œ | 2-3ì‹œê°„ | 7-9ì‹œê°„ |

**ì£¼ê°„ ì´ ì˜ˆìƒ ì‹œê°„**: 11-13.5ì‹œê°„

---

## ğŸ”¥ ì¶”ì²œ í•™ìŠµ ìˆœì„œ

### ì´ˆê¸‰ì (IM ì§‘ì¤‘)
```
1. SWEA_1940 â†’ 2. SWEA_1948 â†’ 3. SWEA_1928 
â†’ 4. SWEA_1859 â†’ 5. SWEA_2805 â†’ 6. SWEA_1215
â†’ 7. SWEA_2117 (ë„ì „)
```

### ì¤‘ê¸‰ì (ê· í˜•)
```
1. SWEA_1859 â†’ 2. SWEA_2805 â†’ 3. SWEA_1215 
â†’ 4. SWEA_2117 â†’ 5. SWEA_1767
â†’ ë‚˜ë¨¸ì§€ IM ë¬¸ì œë“¤ ë¹ ë¥´ê²Œ í•´ê²°
```

### ê³ ê¸‰ì (Aí˜• ì§‘ì¤‘)
```
1. IM ë¬¸ì œ 6ê°œ ë¹ ë¥´ê²Œ í•´ê²° (3-4ì‹œê°„)
â†’ 2. SWEA_1767 â†’ 3. SWEA_2383 â†’ 4. SWEA_2117
â†’ ì½”ë“œ ìµœì í™” ë° ë‹¤ì–‘í•œ í’€ì´ ì‹œë„
```

---

## âœ¨ ì´ë²ˆ ì£¼ íŠ¹ì§•

### ğŸ†• í•µì‹¬ í¬ì¸íŠ¸
- **Greedy ì „ëµ**: ì—­ë°©í–¥ íƒìƒ‰ ê¸°ë²• (ë°±ë§Œ ì¥ì)
- **ë‹¤ì´ì•„ëª¬ë“œ ë²”ìœ„**: ë§¨í•´íŠ¼ ê±°ë¦¬ ê¸°ë°˜ ì˜ì—­ íƒìƒ‰
- **ë³µì¡í•œ ì‹œë®¬ë ˆì´ì…˜**: ë‹¤ì¤‘ ê°ì²´ ìƒíƒœ ê´€ë¦¬
- **ìµœì í™” ë°±íŠ¸ë˜í‚¹**: ê°€ì§€ì¹˜ê¸° ì „ëµ ì‹¬í™”

### ğŸ¯ í•™ìŠµ íš¨ê³¼
1. **IM ì‹¤ì „**: ë‹¤ì–‘í•œ ì•Œê³ ë¦¬ì¦˜ ìœ í˜• ê²½í—˜
2. **Aí˜• ì‹¬í™”**: ì‹¤ì „ê¸‰ ë‚œì´ë„ ë¬¸ì œ ë„ì „
3. **ìµœì í™” ëŠ¥ë ¥**: ì‹œê°„/ê³µê°„ ë³µì¡ë„ ê°œì„  ì—°ìŠµ

---

## ğŸ’ª ì„±ê³µ ì „ëµ

### âœ… ì´ë²ˆ ì£¼ ì§‘ì¤‘ ì‚¬í•­
- **ì—­ë°©í–¥ ì‚¬ê³ **: ë’¤ì—ì„œë¶€í„° íƒìƒ‰í•˜ëŠ” ì „ëµ
- **ë²”ìœ„ ê³„ì‚°**: ë‹¤ì´ì•„ëª¬ë“œ ì˜ì—­ ì •í™•íˆ íŒŒì•…
- **ì‹œë®¬ë ˆì´ì…˜ êµ¬í˜„**: ë³µì¡í•œ ì¡°ê±´ ì²´ê³„ì ìœ¼ë¡œ ì²˜ë¦¬
- **ë°±íŠ¸ë˜í‚¹ ìµœì í™”**: ë¶ˆí•„ìš”í•œ íƒìƒ‰ ì¤„ì´ê¸°

### âŒ ì£¼ì˜ì‚¬í•­
- **ì‹œê°„ ì´ˆê³¼ ì£¼ì˜**: íŠ¹íˆ ë°±ë§Œ ì¥ì ë¬¸ì œ
- **ë²”ìœ„ ê³„ì‚° ì‹¤ìˆ˜**: ë‹¤ì´ì•„ëª¬ë“œ ì˜ì—­ ì •í™•íˆ
- **ì‹œë®¬ë ˆì´ì…˜ ë²„ê·¸**: ì—£ì§€ ì¼€ì´ìŠ¤ ê¼¼ê¼¼íˆ í™•ì¸
- **ë°±íŠ¸ë˜í‚¹ ë³µì›**: ìƒíƒœ ë˜ëŒë¦¬ê¸° ë¹ ëœ¨ë¦¬ì§€ ì•Šê¸°

---

## ğŸ“š í•µì‹¬ ì•Œê³ ë¦¬ì¦˜ í…œí”Œë¦¿

### ì—­ë°©í–¥ Greedy í…œí”Œë¦¿
```python
def reverse_greedy(arr):
    """ë’¤ì—ì„œë¶€í„° ìµœì ê°’ ì°¾ê¸°"""
    result = 0
    max_value = arr[-1]
    
    for i in range(len(arr) - 2, -1, -1):
        if arr[i] >= max_value:
            max_value = arr[i]
        else:
            result += max_value - arr[i]
    
    return result
```

### ë‹¤ì´ì•„ëª¬ë“œ ë²”ìœ„ íƒìƒ‰ í…œí”Œë¦¿
```python
def diamond_range(cx, cy, k):
    """ì¤‘ì‹¬ (cx, cy)ì—ì„œ ê±°ë¦¬ k ì´ë‚´ ì¢Œí‘œë“¤"""
    result = []
    
    for i in range(N):
        for j in range(M):
            # ë§¨í•´íŠ¼ ê±°ë¦¬
            distance = abs(i - cx) + abs(j - cy)
            if distance < k:
                result.append((i, j))
    
    return result
```

### ìµœì í™” ë°±íŠ¸ë˜í‚¹ í…œí”Œë¦¿
```python
def optimized_backtrack(idx, current, best):
    """ê°€ì§€ì¹˜ê¸° ê°•í™” ë°±íŠ¸ë˜í‚¹"""
    global answer
    
    # ê°€ì§€ì¹˜ê¸°: í˜„ì¬ê¹Œì§€ ê²°ê³¼ê°€ ìµœì„ ë³´ë‹¤ ë‚˜ì˜ë©´ ì¤‘ë‹¨
    if current < best:
        return
    
    # ê°€ì§€ì¹˜ê¸°: ë‚¨ì€ ì„ íƒìœ¼ë¡œ ìµœì„  ë‹¬ì„± ë¶ˆê°€ëŠ¥í•˜ë©´ ì¤‘ë‹¨
    if current + remaining_potential(idx) < answer:
        return
    
    # ëª©í‘œ ë‹¬ì„±
    if idx == target:
        answer = max(answer, current)
        return
    
    # ì„ íƒ ì‹œë„
    for choice in get_choices(idx):
        apply(choice)
        optimized_backtrack(idx + 1, new_current, best)
        undo(choice)
```

---

## ğŸ’¬ ì´ë²ˆ ì£¼ íšŒê³ 
(ì£¼ì°¨ ì™„ë£Œ í›„ ì‘ì„±)

### ì–´ë ¤ì› ë˜ ì 
- 

### ìƒˆë¡œ ë°°ìš´ ì 
- 

### ë‹¤ìŒ ì£¼ ëª©í‘œ
-

---

## ğŸ” ì°¸ê³  ìë£Œ

### ë‹¤ì´ì•„ëª¬ë“œ ë²”ìœ„ ì‹œê°í™”
```
K=3ì¸ ê²½ìš°:
    2
  1 1 1
0 0 0 0 0
  1 1 1
    2

ë§¨í•´íŠ¼ ê±°ë¦¬ < 3ì¸ ëª¨ë“  ì 
```

### ì‹œë®¬ë ˆì´ì…˜ ë””ë²„ê¹… íŒ
1. ê° ì‹œê°„ëŒ€ë³„ ìƒíƒœ ì¶œë ¥
2. ì‘ì€ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¡œ ê²€ì¦
3. ê²½ê³„ ì¡°ê±´ ê¼¼ê¼¼íˆ í™•ì¸
4. ìƒíƒœ ë³µì› ì •í™•íˆ êµ¬í˜„

---

**"í•œ ë‹¨ê³„ ë” ê¹Šì´ íŒŒê³ ë“¤ì–´ ì‹¤ë ¥ì„ ì™„ì„±í•˜ì! ğŸ’ª"**